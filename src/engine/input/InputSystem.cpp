// Copyright (c) Lauri MÃ¤kinen 2014 - 2015
// All rights reserved.
#include "engine/precompiled.h"

#include "engine/GameInstance.h"
#include "engine/input/InputSystem.h"
#include "engine/sys/FileSystem.h"

namespace command {
	CREATE_COMMAND(bind, "bind <keycode> <action>")
	{
		engine::input::InputSystem *inputSystem = instance->getInputSystem();

		if (args->size() < 3)
		{
			LOG_WARNING("not enough parameters for bind");
			return -1;
		}

		inputSystem->bindKey(args->at(1), args->at(2));

		return 0;
	}

	CREATE_COMMAND(axis, "axis <axiscode> <action>")
	{
		engine::input::InputSystem *inputSystem = instance->getInputSystem();

		if (args->size() < 3)
		{
			LOG_WARNING("not enough parameters for bind");
			return -1;
		}

		inputSystem->bindAxis(args->at(1), args->at(2));

		return 0;
	}

	// Save keys to disc
	CREATE_COMMAND(writekeys, "writekeys <file(optional)> - save keybinds.")
	{
		if (args->size() == 1)
		{
			instance->getInputSystem()->saveToFile("keys.cfg");
			return 0;
		}

		if (args->size() == 2)
		{
			instance->getInputSystem()->saveToFile(args->at(1));
			return 0;
		}

		return -1;
	}

	CREATE_COMMAND(listbinds, "list all active binds")
	{
		engine::util::Array<String> list;
		instance->getInputSystem()->dumpActiveBinds(list);
		
		for (unsigned i = 0; i < list.getSize(); ++i)
			LOG_INFO("> " + list[i];);

		return 0;
	}
}

namespace engine {
namespace input {

	InputSystem::InputSystem()
	{
		for (unsigned i = 0; i < NUM_KEYS; ++i)
		{
			keyBinds[i] = NULL;
			stringKeyBind[i] = "";
		}

		for (unsigned i = 0; i < NUM_AXIS; ++i)
		{
			axisBinds[i] = NULL;
			stringAxisBind[i] = "";

			axisPosition[i] = math::Vec2(0.f, 0.f);
		}
	}

	InputSystem::~InputSystem()
	{
		// Clear the hashmap from the actions
		util::HashMap<util::BindBase*, 32>::Iterator it = actionList.begin();

		while (!it.isAtEnd())
		{
			util::BindBase *bind = it.getValue();
			delete bind;

			++it;
		}
	}


	void InputSystem::saveToFile(const String &filename)
	{
		PROFILE;

		std::ofstream file(filename.c_str());

		if(!file.is_open())
		{
			LOG_WARNING("Can't open file " << filename << " to save keys!");
			return;
		}

		file << "# This file is automatically generated, edits will be overwritten.\n";

		for (unsigned i = 0; i < NUM_KEYS; ++i)
		{
			if (stringKeyBind[i] != "")
			{
				file << "bind " << keysToString[i] << " " << stringKeyBind[i] << "\n";
			}
		}

		file << "# This file is automatically generated, edits will be overwritten.\n";

		file.close();
	}

	bool InputSystem::init()
	{
		return true;
	}

	void InputSystem::uninit() {}

	void InputSystem::update(float delta) {}

	void InputSystem::keyDown(KeyCode code)
	{
		if (keyBinds[code] == NULL)
			return;

		bool isDown = true;

		engine::stream::InputStream<engine::stream::NativeEndian> params(&isDown);
		keyBinds[code]->call(params);
	}

	void InputSystem::keyUp(KeyCode code)
	{
		if (keyBinds[code] == NULL)
			return;

		bool isDown = false;

		engine::stream::InputStream<engine::stream::NativeEndian> params(&isDown);
		keyBinds[code]->call(params);
	}

	void InputSystem::axisMove(AxisCode axis, float x, float y)
	{
		if (axisBinds[axis] == NULL)
			return;

		stream::BufferedOutputStream<stream::NativeEndian> params;
		params.write(x);
		params.write(y);

		axisBinds[axis]->call(stream::InputStream<stream::NativeEndian>(params.getData()));
	}

	void InputSystem::bindKey(const String &key, const String &action)
	{
		KeyCode keyCode = getKeyForString(key);

		if (keyCode == KEY_VOID)
		{
			LOG_WARNING("Invalid keycode for a bind! ( " << key << ")");
			return;
		}

		stringKeyBind[keyCode] = action;

		util::BindBase *bindBase;
		if (!actionList.find(action, bindBase))
		{
			LOG_WARNING("Could not bind to action: " << action);
			// We are applying it anyway, if we are going to get the action later (TODO: check this behaviour)
			return; //Return away to prevent invalid bind
		}

		// Apply the actual bind!
		keyBinds[keyCode] = bindBase;

		LOG_INFO("Bind " << key << " to " << action);
	}

	void InputSystem::bindAxis(const String &axis, const String &action)
	{
		AxisCode axisCode = getAxisForString(axis);

		if (axisCode == AXIS_VOID)
		{
			LOG_WARNING("Invalid axis for a bind! ( " << axisCode<< ")");
			return;
		}

		stringAxisBind[axisCode] = action;

		util::BindBase *bindBase;
		if (!actionList.find(action, bindBase))
		{
			LOG_WARNING("Could not bind to action: " << action);
			// We are applying it anyway, if we are going to get the action later (TODO: check this behaviour)
			return; // Return away to prevent invalid bind
		}

		// Apply the actual bind!
		axisBinds[axisCode] = bindBase;

		LOG_INFO("Axis " << axis << " to " << action);
	}

	void InputSystem::dumpActiveBinds(util::Array<String> &binds)
	{
		for (unsigned i = 0; i < NUM_KEYS; ++i)
		{
			if (keyBinds[i] != NULL)
			{
				String str(keysToString[i]);

				str.append(" ");

				str.append(stringKeyBind[i]);

				binds.push(str);
			}
		}

		for (unsigned i = 0; i < NUM_AXIS; ++i)
		{
			if (axisBinds[i] != NULL)
			{
				String str(axisToString[i]);

				str.append(" ");

				str.append(stringAxisBind[i]);

				binds.push(str);
			}
		}
	}

}
}